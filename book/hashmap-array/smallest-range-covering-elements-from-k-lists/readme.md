# [632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists)
你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。  
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。
```
示例 1:

输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释:
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。

注意:

给定的列表可能包含重复元素，所以在这里升序表示 >= 。
1 <= k <= 3500
-10^5 <= 元素的值 <= 10^5
对于使用Java的用户，请注意传入类型已修改为List<List<Integer>>。重置代码模板后可以看到这项改动。
```
## 分析
贪心策略。参考如下借助堆的方法和借助哈希表的滑动窗口解法。
## 解法一： 借助堆的贪心解法
问题可以转化为：从 k 个列表中各取一个数，使得这 k 个数中的最大值与最小值的差最小。  
每个列表都是有序的，可以用贪心策略来解决。以题目中给的例子为例，斜体加粗表示选中的数字：
问题可以转化为：从 k 个列表中各取一个数，使得这 k 个数中的最大值与最小值的差最小。  
每个列表都是有序的，可以用贪心策略来解决。以题目中给的例子为例，斜体加粗表示选中的数字：
  
| 0          | 1    | 2    | 3    | 4    |
| ---------- | ---- | ---- | ---- | ---- |
| ***4*** | 10   | 15   | 24   | 26   |
| ***0***   | 9    | 12   | 20   |      |
| ***5***   | 18   | 22   | 30   |      ||

max：5， min：0， abs：5-0=5

| 0        | 1        | 2    | 3    | 4    |
| -------- | -------- | ---- | ---- | ---- |
| ***4*** | 10       | 15   | 24   | 26   |
| 0        | ***9*** | 12   | 20   |      |
| ***5*** | 18       | 22   | 30   |      ||

max：9， min：4， abs：9-4=5 

| 0        | 1         | 2    | 3    | 4    |
| -------- | --------- | ---- | ---- | ---- |
| 4        | ***10*** | 15   | 24   | 26   |
| 0        | ***9***  | 12   | 20   |      |
| ***5*** | 18        | 22   | 30   |      ||

max：10， min：5， abs：10-5=5 

| 0    | 1         | 2    | 3    | 4    |
| ---- | --------- | ---- | ---- | ---- |
| 4    | ***10*** | 15   | 24   | 26   |
| 0    | ***9***  | 12   | 20   |      |
| 5    | ***18*** | 22   | 30   |      ||

max：18， min：9， abs：18-9=9 

| 0    | 1         | 2         | 3    | 4    |
| ---- | --------- | --------- | ---- | ---- |
| 4    | ***10*** | 15        | 24   | 26   |
| 0    | 9         | ***12*** | 20   |      |
| 5    | ***18*** | 22        | 30   |      ||

max：18， min：10， abs：18-10=8 

| 0    | 1         | 2         | 3    | 4    |
| ---- | --------- | --------- | ---- | ---- |
| 4    | 10        | ***15*** | 24   | 26   |
| 0    | 9         | ***12*** | 20   |      |
| 5    | ***18*** | 22        | 30   |      ||

max：18， min：12， abs：18-12=6 

| 0    | 1         | 2         | 3         | 4    |
| ---- | --------- | --------- | --------- | ---- |
| 4    | 10        | ***15*** | 24        | 26   |
| 0    | 9         | 12        | ***20*** |      |
| 5    | ***18*** | 22        | 30        |      ||

max：20， min：15， abs：20-15=5  

| 0    | 1         | 2    | 3         | 4    |
| ---- | --------- | ---- | --------- | ---- |
| 4    | 10        | 15   | ***24*** | 26   |
| 0    | 9         | 12   | ***20*** |      |
| 5    | ***18*** | 22   | 30        |      ||

max：24， min：18， abs：24-18=6 

| 0    | 1    | 2         | 3         | 4    |
| ---- | ---- | --------- | --------- | ---- |
| 4    | 10   | 15        | ***24*** | 26   |
| 0    | 9    | 12        | ***20*** |      |
| 5    | 18   | ***22*** | 30        |      ||

max：24， min：20， abs：24-20=4   
最小值所在列表元素已经尝试完，整个流程结束

以上所有步骤中，abs最小的min和max即为所求
```text
如果每次遍历k次找到k个元素的最小值和最大值，时间复杂度会比较大
可以借助一个大小为k的小顶堆h来记录每次尝试的k个数字，一个变量 curMax 记录k个数字里最大的元素
每次计算 curMax 和堆顶元素的差得到 abs，之后堆顶元素修改成其所在列表的下一个元素
直到某一个列表元素尝试完
```
[参考实现](d.go)
```text
假设所有数字共n个，则时间复杂度为(n*lgk)
空间复杂度O(k)，堆的大小
```
## 解法二：借助哈希表的滑动窗口解法
先统计出所有数字里的最小值 xMin 和最大值 xMax， [xMin, xMax]区间包含了所有数字，答案不会比这个区间更大  
接下来可以用滑动窗口的方式遍历[xMin, xMax]区间来尝试  
窗口左右边界一开始都为xMin，增加right指针，使得对于窗口[left, right]， k 个列表中的每个列表至少有一个数包含在其中；则left， right可能为一个答案  
但这时候可以缩小窗口，增加左边界， 一直维持k 个列表中的每个列表至少有一个数包含在窗口中的性质，直到不再满足这个限制后，停止增加左边界，开始增加右边界  
`为了迅速判断是否 k 个列表中的每个列表至少有一个数包含在窗口中，可以事先用一个哈希表统计每个数字都在哪些列表出现`
[参考实现](dd.go)
```text
假设所有数字共n个， 最大数字与最小数字差为abs，时间复杂度O(max(n, k*abs))
```